<!DOCTYPE html>
<html lang="ca">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Raonament Espacial · Pack (Lite fix v4)</title>
<style>
  :root{
    --bg:#f6f7fb; --fg:#1f2937; --muted:#6b7280;
    --card:#ffffff; --line:#e5e7eb; --primary:#2563eb; --accent:#10b981; --danger:#ef4444;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%}
  body{min-height:100vh;background:var(--bg);color:var(--fg);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  header{position:sticky;top:0;background:#fff;border-bottom:1px solid var(--line);}
  .wrap{max-width:1100px;margin:0 auto;padding:16px;}
  h1{margin:0;font-size:22px}
  main{max-width:1100px;margin:0 auto;padding:16px;}
  .grid{display:grid;gap:12px}
  .hub{grid-template-columns:repeat(auto-fit,minmax(240px,1fr))}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:14px;display:flex;flex-direction:column}
  .card h2{font-size:18px;margin:0 0 6px 0}
  .muted{color:var(--muted);font-size:13px;margin:0 0 10px 0}
  button{cursor:pointer}
  .btn{border:1px solid var(--line);background:#fff;border-radius:10px;padding:10px 12px}
  .btn.primary{background:var(--primary);border-color:var(--primary);color:white}
  .btn.inline{padding:6px 10px;font-size:14px}
  .bar{display:flex;align-items:center;gap:10px;justify-content:space-between;margin-bottom:10px}
  .stats{display:flex;gap:14px;font-size:14px}
  .scene{background:#fff;border:1px solid var(--line);border-radius:12px;padding:12px}
  #gameRoot{min-height:260px}
  canvas{background:white;border:1px solid var(--line);border-radius:8px;touch-action:none}
  /* Symmetry Painter */
  .gridcells{display:grid;gap:1px;background:var(--line);padding:1px;user-select:none;touch-action:none}
  .cell{width:22px;height:22px;background:#fff}
  .cell.on{background:#111827}
  .cell.hint{outline:2px dashed #9ca3af}
  /* D-pad */
  .dpad{display:grid;grid-template-columns:50px 50px 50px;grid-template-rows:50px 50px 50px;gap:6px;justify-content:center}
  .dpad .btn{height:50px}
  /* Pistes Map Hunt */
  .steps{display:flex;flex-wrap:wrap;gap:6px}
  .step{border:1px solid var(--line);border-radius:8px;padding:4px 8px;font-size:13px;background:#fff}
  .step.active{outline:2px solid var(--accent)}
  .step.done{background:#ecfdf5;border-color:#a7f3d0}
  .step.error{background:#fef2f2;border-color:#fecaca}
  footer{color:#6b7280;text-align:center;font-size:12px;padding:16px}
</style>
</head>
<body>
<header>
  <div class="wrap bar">
    <h1>🧠 Raonament Espacial · Pack (Lite)</h1>
    <div>
      <button id="btnHome" class="btn inline">Inici</button>
      <button id="btnResetGlobal" class="btn inline">Reinicia joc</button>
    </div>
  </div>
</header>

<main>
  <!-- HUB -->
  <section id="hub" class="grid hub">
    <article class="card">
      <h2>Rotation Rush</h2>
      <p class="muted">Tria l’única rotació exacta. Les altres 3 estan clarament deformades (escala, cisallament o vèrtexs moguts).</p>
      <button class="btn primary" data-start="rotation_rush">Jugar</button>
    </article>

    <article class="card">
      <h2>Symmetry Painter</h2>
      <p class="muted">Pinta al costat dret i completa la simetria vertical.</p>
      <button class="btn primary" data-start="symmetry_painter">Jugar</button>
    </article>

    <article class="card">
      <h2>Map Hunt</h2>
      <p class="muted">Segueix instruccions pas a pas (E/N/S/W) i completa la ruta.</p>
      <button class="btn primary" data-start="map_hunt">Jugar</button>
    </article>

    <article class="card">
      <h2>Pentomino Packing</h2>
      <p class="muted">Arrossega peces des de la paleta al tauler. Rotar: doble-tap · Reflectir: mantenir.</p>
      <button class="btn primary" data-start="pentomino">Jugar</button>
    </article>

    <article class="card">
      <h2>Paper Nets</h2>
      <p class="muted">Desplegables d’un cub. Mou l’angle i valida.</p>
      <button class="btn primary" data-start="nets">Jugar</button>
    </article>
  </section>

  <!-- ESCENA -->
  <section id="scene" class="scene" style="display:none">
    <div class="bar">
      <div>Joc: <strong id="uiGameName">—</strong></div>
      <div class="stats">
        <div>Punts: <strong id="uiScore">0</strong></div>
        <div>Temps: <strong id="uiTime">—</strong></div>
      </div>
    </div>
    <div id="gameRoot"></div>
    <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap">
      <button id="btnBack" class="btn">Torna</button>
      <button id="btnNext" class="btn">Següent</button>
    </div>
    <p id="globalMessage" class="muted" style="margin-top:8px"></p>
  </section>
</main>

<footer>
  Pack per a GitHub Pages · Sense dependències externes · Llicència: CC BY-NC-SA 4.0
</footer>

<script>
(function(){
  "use strict";

  /* ---------- Utils DOM ---------- */
  const $ = (sel,root=document)=>root.querySelector(sel);
  const $$ = (sel,root=document)=>Array.from(root.querySelectorAll(sel));
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const rnd=(min,max)=>Math.random()*(max-min)+min;
  const avg = arr => arr.reduce((a,b)=>a+b,0)/arr.length;

  /* ---------- Estat app ---------- */
  const hub = $('#hub');
  const scene = $('#scene');
  const root = $('#gameRoot');
  const uiName = $('#uiGameName');
  const uiScore = $('#uiScore');
  const uiTime = $('#uiTime');
  const msg = $('#globalMessage');

  let state = { score:0, timeLeft:null, timerId:null, game:null };

  function setScore(v){ state.score=Math.max(0, v); uiScore.textContent=state.score; }
  function setTime(v){ state.timeLeft = (v==null? null : +v); uiTime.textContent = (state.timeLeft==null?'—':state.timeLeft); }
  function clearTimer(){ if(state.timerId){ clearInterval(state.timerId); state.timerId=null; } }
  function startTimer(){ clearTimer(); if(state.timeLeft==null) return;
    state.timerId=setInterval(()=>{ state.timeLeft--; uiTime.textContent=state.timeLeft;
      if(state.timeLeft<=0){ endGame('lose'); } },1000);
  }
  function endGame(kind){ clearTimer(); alert(kind==='win'?'🎉 Ben fet!':'⏱️ Temps esgotat.'); }

  function showHub(){ clearTimer(); scene.style.display='none'; hub.style.display='grid'; msg.textContent=''; }
  function showScene(){ hub.style.display='none'; scene.style.display='block'; }

  /* ---------- Navegació ---------- */
  function startGame(id){
    try{
      const G = GAMES[id];
      if(!G){ alert('Joc no trobat.'); return; }
      uiName.textContent = G.name || '—';
      setScore(0); setTime(G.timeLimit ?? null);
      root.innerHTML=''; showScene();
      G.init(root,(delta)=> setScore(state.score + delta));
      if(G.timeLimit) startTimer();
      msg.textContent = G.hint || '';
      state.game = G;
    }catch(err){
      console.error(err);
      alert('S\'ha produït un error inicialitzant el joc.');
      showHub();
    }
  }

  function wire(){
    $$('[data-start]').forEach(b => b.addEventListener('click', ()=> startGame(b.dataset.start)));
    $('#btnHome')?.addEventListener('click', showHub);
    $('#btnBack')?.addEventListener('click', showHub);
    $('#btnResetGlobal')?.addEventListener('click', ()=>{
      try{ if(state.game && typeof state.game.reset==='function') state.game.reset(); setScore(0); setTime(state.game?.timeLimit ?? null); }catch(e){ console.error(e); }
    });
    $('#btnNext')?.addEventListener('click', ()=>{ try{ state.game?.next && state.game.next(); }catch(e){ console.error(e); } });
  }
  document.addEventListener('DOMContentLoaded', wire);

  /* ===============================
     GEOMETRIA + RETÍCULA
     =============================== */
  function centroid(poly){ const cx=avg(poly.map(p=>p[0])), cy=avg(poly.map(p=>p[1])); return [cx,cy]; }
  function normalize(poly){ const [cx,cy]=centroid(poly); return poly.map(([x,y])=>[x-cx,y-cy]); }
  function rotate(poly,deg){ const a=deg*Math.PI/180, s=Math.sin(a), c=Math.cos(a); return poly.map(([x,y])=>[x*c-y*s, x*s+y*c]); }
  function translate(poly,dx,dy){ return poly.map(([x,y])=>[x+dx,y+dy]); }
  function scale(poly,sx,sy){ return poly.map(([x,y])=>[x*sx,y*sy]); }
  function shearX(poly,k){ return poly.map(([x,y])=>[x+k*y, y]); }
  function shearY(poly,k){ return poly.map(([x,y])=>[x, y+k*x]); }
  function nudgeVertex(poly,mag=12){
    const count = Math.min(3, Math.max(2, Math.floor(poly.length/3)));
    const idxs=new Set(); while(idxs.size<count) idxs.add(Math.floor(Math.random()*poly.length));
    return poly.map((pt,i)=> idxs.has(i)? [pt[0]+(Math.random()<0.5?-mag:mag), pt[1]+(Math.random()<0.5?-mag:mag)] : pt);
  }
  function drawGrid(ctx, step=20){
    const w=ctx.canvas.width, h=ctx.canvas.height;
    ctx.save(); ctx.strokeStyle='rgba(0,0,0,0.08)'; ctx.lineWidth=1;
    for(let x=step; x<=w-step; x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
    for(let y=step; y<=h-step; y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
    ctx.restore();
  }
  function drawPoly(ctx,poly,{x=0,y=0,stroke='#111827'}={}){
    ctx.save(); ctx.translate(x,y);
    ctx.beginPath();
    ctx.moveTo(poly[0][0], poly[0][1]);
    for(let i=1;i<poly.length;i++) ctx.lineTo(poly[i][0], poly[i][1]);
    ctx.closePath();
    ctx.lineWidth=2.5; ctx.strokeStyle=stroke; ctx.stroke();
    ctx.restore();
  }

  /* ===============================
     Rotation Rush — 1 correcta + 3 clarament deformades
     =============================== */
  const RotationRush = {
    name:'Rotation Rush', timeLimit:20,
    round:0, basePoly:null, choicesWrap:null, baseCtx:null,
    shapeset:[
      [[0,0],[62,6],[52,22],[90,34],[50,54],[74,70],[16,64],[10,42],[28,34],[6,18]],
      [[0,0],[70,0],[70,16],[36,16],[36,56],[14,56],[14,18],[2,18]],
      [[8,20],[58,0],[96,26],[68,36],[88,74],[44,56],[14,70],[30,40]],
      [[0,10],[48,10],[48,26],[34,26],[34,40],[76,40],[76,58],[12,58],[12,28],[0,28]],
      [[0,18],[54,18],[72,6],[88,20],[40,32],[82,44],[62,60],[0,60],[10,40]],
      [[0,8],[64,8],[50,22],[78,22],[28,58],[44,44],[0,44]]
    ],
    hint:'Toca l’única opció que és la rotació exacta (sense deformacions).',
    init(root,onScore){
      this.onScore=onScore; this.round=0;
      const wrap = document.createElement('div');
      wrap.className='grid'; wrap.style.gridTemplateColumns='1fr 1fr'; wrap.style.gap='10px';
      wrap.innerHTML = `
        <div>
          <canvas id="rr-base" width="260" height="260"></canvas>
          <div class="muted" style="margin-top:6px">Tria la rotació correcta (90°, 180° o 270°). La retícula t’ajuda a veure deformacions.</div>
        </div>
        <div><div id="rr-choices" class="grid" style="grid-template-columns:1fr 1fr; gap:8px"></div></div>`;
      root.appendChild(wrap);
      this.choicesWrap = wrap.querySelector('#rr-choices');
      this.baseCtx = wrap.querySelector('#rr-base').getContext('2d');
      this.next();
    },
    reset(){ this.round=0; this.next(); },
    next(){
      setTime(this.timeLimit); startTimer();
      this.round++; if(this.round>10){ endGame('win'); return; }

      const raw = this.shapeset[Math.floor(Math.random()*this.shapeset.length)];
      const base = normalize(raw);
      this.baseCtx.clearRect(0,0,260,260);
      drawGrid(this.baseCtx, 20);
      drawPoly(this.baseCtx, translate(base,130,130));

      const angles=[90,180,270];
      const correctAngle = angles[Math.floor(Math.random()*angles.length)];
      const exact = rotate(base, correctAngle);

      const d1 = scale(exact, Math.random()<0.5?0.72:1.28, Math.random()<0.5?1.28:0.72);
      const d2 = (Math.random()<0.5? shearX(exact, 0.28) : shearY(exact, 0.28));
      const d3 = nudgeVertex(exact, 18);

      let options = [
        {poly: exact, exact:true},
        {poly: d1, exact:false},
        {poly: d2, exact:false},
        {poly: d3, exact:false}
      ];
      for (let i=options.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [options[i],options[j]]=[options[j],options[i]]; }

      this.choicesWrap.innerHTML='';
      options.forEach(opt=>{
        const cv=document.createElement('canvas'); cv.width=140; cv.height=140;
        const ctx=cv.getContext('2d');
        drawGrid(ctx, 20);
        drawPoly(ctx, translate(opt.poly,70,70));
        cv.addEventListener('click',()=> this.pick(opt.exact));
        this.choicesWrap.appendChild(cv);
      });
    },
    pick(ok){ if(ok){ this.onScore(10); this.next(); } else { this.onScore(-2); } }
  };

  /* ===============================
     Symmetry Painter
     =============================== */
  const SymmetryPainter = {
    name:'Symmetry Painter', timeLimit:null,
    levelIndex:0, rows:0, cols:0, grid:[], target:[],
    levels:[
      {rows:12, cols:16, target:(r,c)=>(r>2&&r<9&&c<4&&(r+c)%2===0)},
      {rows:14, cols:20, target:(r,c)=>((r>3&&r<10&&c<6)&&(r%3===0||c%2===0))},
      {rows:16, cols:22, target:(r,c)=>((r>4&&r<12&&c<7)&&((r+c)%3===0))}
    ],
    hint:'Arrossega per pintar a la meitat dreta.',
    init(root,onScore){
      this.onScore=onScore; this.levelIndex=0;
      const wrap=document.createElement('div');
      wrap.innerHTML=`<div class="muted" style="margin-bottom:6px">Completa la simetria vertical</div>
        <div id="sym" class="gridcells"></div>`;
      root.appendChild(wrap);
      this.gridEl = $('#sym', wrap);
      this.load(0);
    },
    next(){ this.load((this.levelIndex+1)%this.levels.length); },
    load(i){
      this.levelIndex=i;
      const L=this.levels[i]; this.rows=L.rows; this.cols=L.cols;
      const half=Math.floor(this.cols/2);
      this.target=Array.from({length:this.rows},(_,r)=>Array.from({length:this.cols},(_,c)=> (c<half && L.target(r,c)?1:0)));
      this.grid=Array.from({length:this.rows},()=>Array(this.cols).fill(0));
      this.render();
    },
    render(){
      const g=this.gridEl;
      g.innerHTML=''; g.style.gridTemplateColumns=`repeat(${this.cols},22px)`;
      let painting=false;
      const toggle=(r,c)=>{ if(c<Math.floor(this.cols/2)) return; this.grid[r][c]=this.grid[r][c]?0:1; };
      for(let r=0;r<this.rows;r++) for(let c=0;c<this.cols;c++){
        const d=document.createElement('div'); d.className='cell';
        if(this.target[r][c]===1) d.classList.add('hint');
        if(this.grid[r][c]===1) d.classList.add('on');
        d.addEventListener('mousedown',(e)=>{ e.preventDefault(); painting=true; toggle(r,c); this.render(); });
        d.addEventListener('mouseover',()=>{ if(painting){ toggle(r,c); this.render(); }});
        d.addEventListener('touchstart',(e)=>{ e.preventDefault(); painting=true; toggle(r,c); this.render(); },{passive:false});
        d.addEventListener('touchmove',(e)=>{ e.preventDefault(); const t=e.changedTouches[0]; const el=document.elementFromPoint(t.clientX,t.clientY); if(el&&el.classList.contains('cell')) el.dispatchEvent(new Event('mouseover')); },{passive:false});
        g.appendChild(d);
      }
      const up=()=>painting=false;
      document.addEventListener('mouseup',up,{once:true});
      document.addEventListener('touchend',up,{once:true});
      this.check();
    },
    check(){
      const mid=Math.floor(this.cols/2);
      for(let r=0;r<this.rows;r++) for(let c=0;c<mid;c++)
        if(this.target[r][c]!==this.grid[r][this.cols-1-c]) return;
      this.onScore(20);
    }
  };

  /* ===============================
     Map Hunt — amb instruccions pas a pas
     =============================== */
  const MapHunt = {
    name:'Map Hunt', timeLimit:null,
    idx:0, rows:0, cols:0, cell:34, player:{r:0,c:0},
    steps:[], stepIdx:0, stepLeft:0,
    levels:[
      {rows:8,cols:8,start:[3,3],steps:['E2','S3','W1','N1','E2']},
      {rows:10,cols:10,start:[1,1],steps:['E3','S2','E1','S1','W4','N2']},
      {rows:12,cols:12,start:[6,2],steps:['N2','E4','S1','E2','S3','W3','N1']}
    ],
    hint:'Segueix exactament les instruccions. Direccions: N (amunt), S (avall), E (dreta), W (esquerra).',
    init(root,onScore){
      this.onScore=onScore; this.idx=0;
      const wrap=document.createElement('div');
      wrap.innerHTML=`<div style="display:grid;grid-template-columns:minmax(260px,1fr) 250px;gap:12px;align-items:start">
        <div>
          <canvas id="mh" width="340" height="368" aria-label="Mapa"></canvas>
          <div class="muted" style="margin-top:6px">Llisca sobre el mapa o usa el D-pad.</div>
        </div>
        <div>
          <div class="dpad" style="margin-bottom:10px">
            <div></div><button class="btn" data-dir="N" aria-label="Amunt">▲</button><div></div>
            <button class="btn" data-dir="W" aria-label="Esquerra">◀</button><div class="btn" disabled>·</div><button class="btn" data-dir="E" aria-label="Dreta">▶</button>
            <div></div><button class="btn" data-dir="S" aria-label="Avall">▼</button><div></div>
          </div>
          <div class="muted" style="margin:6px 0">Instruccions:</div>
          <div id="mhSteps" class="steps"></div>
          <div id="mhStatus" class="muted" style="margin-top:8px"></div>
          <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap">
            <button id="mhReset" class="btn">Reinicia nivell</button>
            <button id="mhNext" class="btn">Següent nivell</button>
          </div>
        </div>
      </div>`;
      root.appendChild(wrap);
      this.cv = $('#mh', wrap); this.ctx=this.cv.getContext('2d');
      this.stepsEl = $('#mhSteps', wrap); this.statusEl = $('#mhStatus', wrap);
      $('#mhReset', wrap).addEventListener('click',()=> this.load(this.idx));
      $('#mhNext', wrap).addEventListener('click',()=> this.next());
      $$('[data-dir]', wrap).forEach(b=> b.addEventListener('click',()=> this.moveBy(b.dataset.dir)));

      // Gestos (pointer/touch/mouse)
      let down=false, sx=0, sy=0;
      const onDown = (x,y)=>{ down=true; sx=x; sy=y; };
      const onUp = (x,y)=>{ if(!down) return; down=false;
        const dx=x-sx, dy=y-sy;
        if(Math.abs(dx)<20 && Math.abs(dy)<20) return;
        if(Math.abs(dx)>Math.abs(dy)) this.moveBy(dx>0?'E':'W'); else this.moveBy(dy>0?'S':'N');
      };
      this.cv.addEventListener('pointerdown',e=>{ e.preventDefault(); onDown(e.clientX,e.clientY); this.cv.setPointerCapture(e.pointerId); },{passive:false});
      this.cv.addEventListener('pointerup',e=>{ e.preventDefault(); onUp(e.clientX,e.clientY); },{passive:false});
      this.cv.addEventListener('touchstart',e=>{ e.preventDefault(); const t=e.changedTouches[0]; onDown(t.clientX,t.clientY); },{passive:false});
      this.cv.addEventListener('touchend',e=>{ e.preventDefault(); const t=e.changedTouches[0]; onUp(t.clientX,t.clientY); },{passive:false});
      this.cv.addEventListener('mousedown',e=>{ e.preventDefault(); onDown(e.clientX,e.clientY); });
      this.cv.addEventListener('mouseup',e=>{ e.preventDefault(); onUp(e.clientX,e.clientY); });

      this.load(0);
    },
    next(){ this.load((this.idx+1)%this.levels.length); },
    load(i){
      this.idx=i; const L=this.levels[i];
      this.rows=L.rows; this.cols=L.cols;
      this.player={r:L.start[0],c:L.start[1]};
      this.steps=[...L.steps]; this.stepIdx=0; this.stepLeft=parseInt(this.steps[0].slice(1),10);
      this.cv.width=this.cols*this.cell; this.cv.height=this.rows*this.cell+28;
      this.renderSteps(); this.statusEl.textContent='Segueix la primera instrucció.';
      this.draw();
    },
    renderSteps(){
      this.stepsEl.innerHTML='';
      this.steps.forEach((s,idx)=>{
        const el=document.createElement('span');
        el.className='step'+(idx<this.stepIdx?' done': idx===this.stepIdx?' active':'');
        el.textContent=s;
        this.stepsEl.appendChild(el);
      });
    },
    moveBy(dir){
      const current = this.steps[this.stepIdx];
      const needDir = current[0];
      if(dir!==needDir){
        this.statusEl.textContent='Direcció incorrecta. Torna-ho a provar.';
        this.stepsEl.children[this.stepIdx]?.classList.add('error');
        setTimeout(()=> this.stepsEl.children[this.stepIdx]?.classList.remove('error'), 350);
        return;
      }
      this.move( (dir==='S')?1:(dir==='N')?-1:0, (dir==='E')?1:(dir==='W')?-1:0 );
      this.stepLeft--;
      if(this.stepLeft<=0){
        this.stepIdx++;
        if(this.stepIdx>=this.steps.length){
          this.statusEl.textContent='🎯 Ruta completa!';
          this.onScore(20); return;
        }
        this.stepLeft=parseInt(this.steps[this.stepIdx].slice(1),10);
        this.statusEl.textContent='Bé! Segueix: '+this.steps[this.stepIdx];
        this.renderSteps();
      }else{
        this.statusEl.textContent='Queden '+this.stepLeft+' passos en '+needDir+'.';
      }
    },
    move(dr,dc){
      this.player.r=clamp(this.player.r+dr,0,this.rows-1);
      this.player.c=clamp(this.player.c+dc,0,this.cols-1);
      this.draw();
    },
    draw(){
      const g=this.ctx, cs=this.cell; g.clearRect(0,0,this.cv.width,this.cv.height);
      g.strokeStyle='#e5e7eb';
      for(let r=0;r<this.rows;r++) for(let c=0;c<this.cols;c++) g.strokeRect(c*cs, r*cs, cs, cs);
      g.fillStyle='rgba(16,185,129,0.18)'; g.fillRect(0, this.rows*cs, this.cv.width, 28);
      g.fillStyle='#2563eb'; g.fillRect(this.player.c*cs+4, this.player.r*cs+4, cs-8, cs-8);
      g.fillStyle='#1f2937'; g.font='12px system-ui'; g.fillText('Pas: '+(this.stepIdx+1)+'/'+this.steps.length, 8, this.rows*cs+18);
    }
  };

  /* ===============================
     Pentomino — sense imatge fantasma + moure sense duplicar
     =============================== */
  const Pentomino = {
    name:'Pentomino Packing', timeLimit:null,
    level:0, rows:0, cols:0, cell:40, board:[], pieces:[],
    active:null, dragging:false, dragFrom:'', dragOff:[0,0], pendingDrop:false, prevPos:null,
    hint:'Arrossega una peça des de la paleta fins al tauler. Doble-tap: rotar · Mantén: reflectir.',
    baseShapes: {
      F:[[0,1],[1,0],[1,1],[1,2],[2,2]],
      L:[[0,0],[1,0],[2,0],[3,0],[3,1]],
      P:[[0,0],[0,1],[1,0],[1,1],[2,0]],
      T:[[0,0],[0,1],[0,2],[1,1],[2,1]],
      Z:[[0,0],[0,1],[1,1],[1,2],[1,3]],
      U:[[0,0],[0,2],[1,0],[1,1],[1,2]],
      V:[[0,0],[1,0],[2,0],[2,1],[2,2]]
    },
    levels:[
      {rows:7,cols:7,pieces:['F','L','P','T','Z']},
      {rows:8,cols:8,pieces:['F','L','P','T','Z','U','V']}
    ],
    init(root,onScore){
      this.onScore=onScore; this.level=0;
      const wrap=document.createElement('div');
      wrap.innerHTML=`
        <div style="display:grid;grid-template-columns:1fr 260px;gap:12px;align-items:start">
          <div>
            <div class="muted" style="margin-bottom:6px">1) Tria i arrossega · 2) Deixa-la sobre el tauler · 3) Ajusta-la arrossegant</div>
            <canvas id="pento"></canvas>
          </div>
          <div>
            <div id="pList" style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:8px"></div>
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <button id="btnRot" class="btn">↻ Rotar</button>
              <button id="btnFlip" class="btn">⇋ Reflectir</button>
              <button id="btnResetP" class="btn">Reinicia</button>
            </div>
            <p class="muted" style="margin-top:6px">Consells: doble-tap = rotar · mantenir = reflectir</p>
          </div>
        </div>`;
      root.appendChild(wrap);
      this.cv = $('#pento', wrap); this.ctx=this.cv.getContext('2d'); this.pList=$('#pList', wrap);
      $('#btnRot', wrap).addEventListener('click',()=>{ if(this.active!=null){ this.rotate(this.active); this.draw(); }});
      $('#btnFlip', wrap).addEventListener('click',()=>{ if(this.active!=null){ this.reflect(this.active); this.draw(); }});
      $('#btnResetP', wrap).addEventListener('click',()=> this.load(this.level));
      this.load(0);

      // Drag des de la paleta (sense imatge fantasma)
      this.startPaletteDrag = (e)=>{
        const target = e.target.closest('canvas'); if(!target) return;
        e.preventDefault();
        const idx = Number(target.dataset.idx);
        this.active = idx; this.dragging=true; this.dragFrom='palette'; this.pendingDrop=true;
        const move=(ev)=>{ const x=ev.clientX||(ev.touches&&ev.touches[0].clientX); const y=ev.clientY||(ev.touches&&ev.touches[0].clientY); this.drawHover(x,y); };
        const up=(ev)=>{ document.removeEventListener('mousemove',move); document.removeEventListener('touchmove',move); document.removeEventListener('mouseup',up); document.removeEventListener('touchend',up);
          const x=ev.clientX||(ev.changedTouches&&ev.changedTouches[0].clientX); const y=ev.clientY||(ev.changedTouches&&ev.changedTouches[0].clientY);
          this.dropAt(x,y);
        };
        document.addEventListener('mousemove',move); document.addEventListener('touchmove',move,{passive:false});
        document.addEventListener('mouseup',up); document.addEventListener('touchend',up);
      };
      this.pList.addEventListener('mousedown',(e)=> this.startPaletteDrag(e));
      this.pList.addEventListener('touchstart',(e)=> this.startPaletteDrag(e), {passive:false});

      // Drag dins el tauler (moure sense duplicar)
      let pressTimer=null, lastTap=0;
      this.cv.addEventListener('pointerdown',(e)=>{ e.preventDefault();
        const {x,y}=this.xy(e); const g=this.toGrid(x,y);
        this.active=this.hitPiece(g.r,g.c);
        if(this.active!=null){
          // DESENGANXA la peça del tauler per evitar duplicats i poder-la moure
          this.prevPos = {...this.pieces[this.active].pos};
          this.lift(this.active);
          this.dragging=true; this.dragFrom='board';
          this.dragOff=[g.c-this.pieces[this.active].pos.x, g.r-this.pieces[this.active].pos.y];
          const t=Date.now(); if(t-lastTap<280){ this.rotate(this.active); this.draw(); lastTap=0; return; } lastTap=t;
          clearTimeout(pressTimer); pressTimer=setTimeout(()=>{ if(this.active!=null){ this.reflect(this.active); this.draw(); } },400);
          this.cv.setPointerCapture(e.pointerId);
        }
      },{passive:false});
      this.cv.addEventListener('pointermove',(e)=>{ if(this.active==null || !this.dragging || this.dragFrom!=='board') return; clearTimeout(pressTimer);
        const {x,y}=this.xy(e); const g=this.toGrid(x,y);
        const p=this.pieces[this.active]; p.pos={x:g.c - this.dragOff[0], y:g.r - this.dragOff[1]};
        this.draw();
      });
      this.cv.addEventListener('pointerup',()=>{ if(this.active==null || this.dragFrom!=='board') return; this.dragging=false;
        const p=this.pieces[this.active];
        if(this.canPlace(p)){ this.place(p,this.active); this.onScore(2); this.prevPos=null; }
        else { // si no es pot, retorna a la posició prèvia
          p.pos = {...this.prevPos}; this.place(p,this.active); this.prevPos=null;
        }
        this.draw(); if(this.isComplete()){ this.onScore(30); alert('🧩 Tauler completat!'); }
      });
    },
    next(){ this.load((this.level+1)%this.levels.length); },
    load(i){
      this.level=i; const L=this.levels[i];
      this.rows=L.rows; this.cols=L.cols; this.cv.width=this.cols*this.cell; this.cv.height=this.rows*this.cell;
      this.board=Array.from({length:this.rows},()=>Array(this.cols).fill(-1));
      this.pieces = L.pieces.map(k=>({id:k,cells:this.baseShapes[k].map(p=>[...p]),pos:{x:-999,y:-999},color:this.rand()}));
      this.renderPallet(); this.active=null; this.pendingDrop=false; this.dragging=false; this.prevPos=null; this.draw();
    },
    renderPallet(){
      this.pList.innerHTML='';
      this.pieces.forEach((pc,idx)=>{
        const c=document.createElement('canvas'); c.width=110; c.height=78; c.style.background='#fff'; c.style.border='1px solid var(--line)'; c.style.borderRadius='8px';
        c.dataset.idx=idx;
        const g=c.getContext('2d'); const s=16; g.fillStyle=pc.color; pc.cells.forEach(([r,cx])=> g.fillRect(10+cx*s,10+r*s,s-2,s-2));
        c.addEventListener('click',()=>{ this.active=idx; this.pendingDrop=true; });
        this.pList.appendChild(c);
      });
    },
    rand(){ const cs=['#ef4444','#f59e0b','#10b981','#3b82f6','#a855f7','#ec4899','#14b8a6']; return cs[Math.floor(Math.random()*cs.length)]; },
    xy(e){ const b=this.cv.getBoundingClientRect(); return {x:e.clientX-b.left, y:e.clientY-b.top}; },
    toGrid(x,y){ return { c:Math.floor(x/this.cell), r:Math.floor(y/this.cell) }; },
    hitPiece(r,c){ for(let i=this.pieces.length-1;i>=0;i--){ const p=this.pieces[i]; for(const [rr,cc] of p.cells){ if(p.pos.y+rr===r && p.pos.x+cc===c) return i; } } return null; },
    rotate(i){ const p=this.pieces[i]; p.cells=p.cells.map(([r,c])=>[c,-r]); const mr=Math.min(...p.cells.map(q=>q[0])), mc=Math.min(...p.cells.map(q=>q[1])); p.cells=p.cells.map(([r,c])=>[r-mr,c-mc]); },
    reflect(i){ const p=this.pieces[i]; const mc=Math.max(...p.cells.map(q=>q[1])); p.cells=p.cells.map(([r,c])=>[r,mc-c]); },
    lift(idx){ // neteja el tauler de la peça idx
      for(let r=0;r<this.rows;r++) for(let c=0;c<this.cols;c++) if(this.board[r][c]===idx) this.board[r][c]=-1;
    },
    canPlaceAt(p, pos){ for(const [r,c] of p.cells){ const R=pos.y+r, C=pos.x+c; if(R<0||C<0||R>=this.rows||C>=this.cols) return false; if(this.board[R][C]!==-1) return false; } return true; },
    canPlace(p){ return this.canPlaceAt(p,p.pos); },
    place(p,idx){ for(const [r,c] of p.cells){ this.board[p.pos.y+r][p.pos.x+c]=idx; } },
    isComplete(){ for(let r=0;r<this.rows;r++) for(let c=0;c<this.cols;c++) if(this.board[r][c]===-1) return false; return true; },
    drawHover(pageX,pageY){
      const rect=this.cv.getBoundingClientRect();
      const gx = Math.floor((pageX-rect.left)/this.cell);
      const gy = Math.floor((pageY-rect.top)/this.cell);
      const p=this.pieces[this.active];
      const pos={x:gx, y:gy};
      const ok=this.canPlaceAt(p,pos);
      this.draw(pos, ok);
    },
    dropAt(pageX,pageY){
      const rect=this.cv.getBoundingClientRect();
      const gx = Math.floor((pageX-rect.left)/this.cell);
      const gy = Math.floor((pageY-rect.top)/this.cell);
      const p=this.pieces[this.active];
      const pos={x:gx, y:gy};
      if(this.canPlaceAt(p,pos)){ p.pos=pos; this.place(p,this.active); this.onScore(3); this.draw(); if(this.isComplete()){ this.onScore(30); alert('🧩 Tauler completat!'); } }
      else { this.draw(); }
    },
    draw(hoverPos=null, hoverOk=false){
      const g=this.ctx, cs=this.cell; g.clearRect(0,0,this.cv.width,this.cv.height);
      g.strokeStyle='#e5e7eb'; for(let r=0;r<this.rows;r++) for(let c=0;c<this.cols;c++) g.strokeRect(c*cs,r*cs,cs,cs);

      // peces col·locades
      for(let r=0;r<this.rows;r++) for(let c=0;c<this.cols;c++){ const idx=this.board[r][c]; if(idx>=0){ g.fillStyle=this.pieces[idx].color; g.fillRect(c*cs+1,r*cs+1,cs-2,cs-2); } }

      // suggeriment (hover) en arrossegar des de paleta
      if(hoverPos && this.active!=null){
        const p=this.pieces[this.active];
        g.globalAlpha=0.5; g.fillStyle= hoverOk ? 'rgba(16,185,129,.6)' : 'rgba(239,68,68,.6)';
        p.cells.forEach(([rr,cc])=>{
          const R=hoverPos.y+rr, C=hoverPos.x+cc;
          if(R>=0&&C>=0&&R<this.rows&&C<this.cols) g.fillRect(C*cs+1,R*cs+1,cs-2,cs-2);
        });
        g.globalAlpha=1;
      }

      // peces “desenganxades” o en moviment dins el tauler (es mostren per sobre)
      this.pieces.forEach((p)=>{ const anyInside = p.cells.some(([rr,cc])=>{ const R=p.pos.y+rr, C=p.pos.x+cc; return (R>=0&&C>=0&&R<this.rows&&C<this.cols); }); if(!anyInside) return;
        g.fillStyle=p.color; p.cells.forEach(([rr,cc])=>{ const R=p.pos.y+rr, C=p.pos.x+cc; if(R>=0&&C>=0&&R<this.rows&&C<this.cols) g.fillRect(C*cs+1,R*cs+1,cs-2,cs-2); });
      });
    }
  };

  /* ===============================
     Paper Nets
     =============================== */
  const Nets = {
    name:'Paper Nets', timeLimit:null, idx:0, angle:25,
    levels:[
      {layout:[[0,1,0],[1,1,1],[0,1,0]],valid:true,label:'Creu (vàlid)'},
      {layout:[[1,1,1,1,1,1]],valid:false,label:'Tira de 6 (no vàlid)'},
      {layout:[[0,1,0],[1,1,1],[0,0,1]],valid:false,label:'T incomplet'}
    ],
    init(root,onScore){
      this.onScore=onScore; this.idx=0;
      const wrap=document.createElement('div');
      wrap.innerHTML=`<div style="display:grid;grid-template-columns:1fr 220px;gap:10px;align-items:start">
        <canvas id="netcv" width="520" height="340"></canvas>
        <div>
          <label class="muted">Angle: <span id="angv">25</span>°</label>
          <input id="angle" type="range" min="0" max="90" value="25" style="width:100%">
          <div style="display:flex;gap:6px;margin-top:8px">
            <button id="validate" class="btn">Valida</button>
            <button id="nextNet" class="btn">Següent</button>
          </div>
          <p id="netLabel" class="muted" style="margin-top:6px"></p>
        </div>
      </div>`;
      root.appendChild(wrap);
      this.cv=$('#netcv',wrap); this.ctx=this.cv.getContext('2d');
      $('#angle',wrap).addEventListener('input',(e)=>{ this.angle=+e.target.value; $('#angv',wrap).textContent=this.angle; this.draw(); });
      $('#validate',wrap).addEventListener('click',()=> this.validate());
      $('#nextNet',wrap).addEventListener('click',()=> this.next());
      this.load(0);
    },
    next(){ this.load((this.idx+1)%this.levels.length); },
    load(i){ this.idx=i; $('#netLabel').textContent=this.levels[i].label; this.draw(); },
    validate(){ const L=this.levels[this.idx]; if(L.valid){ this.onScore(10); alert('✅ És un desplegable vàlid.'); } else { this.onScore(-2); alert('❌ No plega a un cub.'); } },
    draw(){
      const ctx=this.ctx,W=this.cv.width,H=this.cv.height; ctx.clearRect(0,0,W,H);
      const m=this.levels[this.idx].layout; const nR=m.length, nC=Math.max(...m.map(r=>r.length));
      const s=Math.min((W-60)/nC,(H-60)/nR); const ox=(W-nC*s)/2, oy=(H-nR*s)/2;
      ctx.strokeStyle='#9ca3af'; ctx.lineWidth=1.5;
      for(let r=0;r<nR;r++) for(let c=0;c<m[r].length;c++) if(m[r][c]){ ctx.strokeRect(ox+c*s, oy+r*s, s, s); ctx.fillStyle='rgba(37,99,235,0.08)'; ctx.fillRect(ox+c*s, oy+r*s, s, s); }
      const lift=Math.sin(this.angle*Math.PI/180)*s;
      let cr=0,cc=0; outer: for(let r=0;r<nR;r++) for(let c=0;c<nC;c++) if(m[r][c]){ cr=r; cc=c; break outer; }
      ctx.fillStyle='rgba(16,185,129,0.15)'; ctx.fillRect(ox+cc*s, oy+cr*s-lift, s, s);
      ctx.strokeStyle='#10b981'; ctx.strokeRect(ox+cc*s, oy+cr*s-lift, s, s);
    }
  };

  /* ---------- Registre ---------- */
  const GAMES = {
    rotation_rush: RotationRush,
    symmetry_painter: SymmetryPainter,
    map_hunt: MapHunt,
    pentomino: Pentomino,
    nets: Nets
  };

  window.startGame = startGame; // opcional consola
})();
</script>
</body>
</html>
