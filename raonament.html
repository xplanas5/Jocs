<!DOCTYPE html>
<html lang="ca">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Raonament Espacial · Pack (Lite fix)</title>
<style>
  :root{
    --bg:#f6f7fb; --fg:#1f2937; --muted:#6b7280;
    --card:#ffffff; --line:#e5e7eb; --primary:#2563eb; --accent:#10b981;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%}
  body{min-height:100vh;background:var(--bg);color:var(--fg);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  header{position:sticky;top:0;background:#fff;border-bottom:1px solid var(--line);}
  .wrap{max-width:1100px;margin:0 auto;padding:16px;}
  h1{margin:0;font-size:22px}
  main{max-width:1100px;margin:0 auto;padding:16px;}
  .grid{display:grid;gap:12px}
  .hub{grid-template-columns:repeat(auto-fit,minmax(240px,1fr))}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:14px;display:flex;flex-direction:column}
  .card h2{font-size:18px;margin:0 0 6px 0}
  .muted{color:var(--muted);font-size:13px;margin:0 0 10px 0}
  button{cursor:pointer}
  .btn{border:1px solid var(--line);background:#fff;border-radius:10px;padding:10px 12px}
  .btn.primary{background:var(--primary);border-color:var(--primary);color:white}
  .btn.inline{padding:6px 10px;font-size:14px}
  .bar{display:flex;align-items:center;gap:10px;justify-content:space-between;margin-bottom:10px}
  .stats{display:flex;gap:14px;font-size:14px}
  .scene{background:#fff;border:1px solid var(--line);border-radius:12px;padding:12px}
  #gameRoot{min-height:260px}
  canvas{background:white;border:1px solid var(--line);border-radius:8px;touch-action:none}
  /* Symmetry Painter */
  .gridcells{display:grid;gap:1px;background:var(--line);padding:1px;user-select:none;touch-action:none}
  .cell{width:22px;height:22px;background:#fff}
  .cell.on{background:#111827}
  .cell.hint{outline:2px dashed #9ca3af}
  /* D-pad */
  .dpad{display:grid;grid-template-columns:50px 50px 50px;grid-template-rows:50px 50px 50px;gap:6px;justify-content:center}
  .dpad .btn{height:50px}
  footer{color:#6b7280;text-align:center;font-size:12px;padding:16px}
</style>
</head>
<body>
<header>
  <div class="wrap bar">
    <h1>🧠 Raonament Espacial · Pack (Lite)</h1>
    <div>
      <button id="btnHome" class="btn inline">Inici</button>
      <button id="btnResetGlobal" class="btn inline">Reinicia joc</button>
    </div>
  </div>
</header>

<main>
  <!-- HUB -->
  <section id="hub" class="grid hub">
    <article class="card">
      <h2>Rotation Rush</h2>
      <p class="muted">Tria la rotació correcta d’una figura; 3 opcions tenen canvis mínims.</p>
      <button class="btn primary" data-start="rotation_rush">Jugar</button>
    </article>

    <article class="card">
      <h2>Symmetry Painter</h2>
      <p class="muted">Pinta al costat dret i completa la simetria vertical.</p>
      <button class="btn primary" data-start="symmetry_painter">Jugar</button>
    </article>

    <article class="card">
      <h2>Map Hunt</h2>
      <p class="muted">Mou-te pel mapa (llisca o D-pad) i arriba a les vores.</p>
      <button class="btn primary" data-start="map_hunt">Jugar</button>
    </article>

    <article class="card">
      <h2>Pentomino Packing</h2>
      <p class="muted">Toca una peça, deixa-la al tauler i arrossega.</p>
      <button class="btn primary" data-start="pentomino">Jugar</button>
    </article>

    <article class="card">
      <h2>Paper Nets</h2>
      <p class="muted">Desplegables d’un cub. Mou l’angle i valida.</p>
      <button class="btn primary" data-start="nets">Jugar</button>
    </article>
  </section>

  <!-- ESCENA -->
  <section id="scene" class="scene" style="display:none">
    <div class="bar">
      <div>Joc: <strong id="uiGameName">—</strong></div>
      <div class="stats">
        <div>Punts: <strong id="uiScore">0</strong></div>
        <div>Temps: <strong id="uiTime">—</strong></div>
      </div>
    </div>
    <div id="gameRoot"></div>
    <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap">
      <button id="btnBack" class="btn">Torna</button>
      <button id="btnNext" class="btn">Següent</button>
    </div>
    <p id="globalMessage" class="muted" style="margin-top:8px"></p>
  </section>
</main>

<footer>
  Pack per a GitHub Pages · Sense dependències externes · Llicència: CC BY-NC-SA 4.0
</footer>

<script>
(function(){
  "use strict";

  /* ---------- Utils DOM ---------- */
  const $ = (sel,root=document)=>root.querySelector(sel);
  const $$ = (sel,root=document)=>Array.from(root.querySelectorAll(sel));
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));

  /* ---------- Estat app ---------- */
  const hub = $('#hub');
  const scene = $('#scene');
  const root = $('#gameRoot');
  const uiName = $('#uiGameName');
  const uiScore = $('#uiScore');
  const uiTime = $('#uiTime');
  const msg = $('#globalMessage');

  let state = { score:0, timeLeft:null, timerId:null, game:null };

  function setScore(v){ state.score=Math.max(0, v); uiScore.textContent=state.score; }
  function setTime(v){ state.timeLeft = (v==null? null : +v); uiTime.textContent = (state.timeLeft==null?'—':state.timeLeft); }
  function clearTimer(){ if(state.timerId){ clearInterval(state.timerId); state.timerId=null; } }
  function startTimer(){ clearTimer(); if(state.timeLeft==null) return;
    state.timerId=setInterval(()=>{ state.timeLeft--; uiTime.textContent=state.timeLeft;
      if(state.timeLeft<=0){ endGame('lose'); } },1000);
  }
  function endGame(kind){ clearTimer(); alert(kind==='win'?'🎉 Ben fet!':'⏱️ Temps esgotat.'); }

  function showHub(){ clearTimer(); scene.style.display='none'; hub.style.display='grid'; msg.textContent=''; }
  function showScene(){ hub.style.display='none'; scene.style.display='block'; }

  /* ---------- Navegació ---------- */
  function startGame(id){
    try{
      const G = GAMES[id];
      if(!G){ alert('Joc no trobat.'); return; }
      uiName.textContent = G.name || '—';
      setScore(0); setTime(G.timeLimit ?? null);
      root.innerHTML=''; showScene();
      G.init(root,(delta)=> setScore(state.score + delta));
      if(G.timeLimit) startTimer();
      msg.textContent = G.hint || '';
      state.game = G;
    }catch(err){
      console.error(err);
      alert('S\'ha produït un error inicialitzant el joc.');
      showHub();
    }
  }

  function wire(){
    $$('[data-start]').forEach(b => b.addEventListener('click', ()=> startGame(b.dataset.start)));
    $('#btnHome')?.addEventListener('click', showHub);
    $('#btnBack')?.addEventListener('click', showHub);
    $('#btnResetGlobal')?.addEventListener('click', ()=>{
      try{ if(state.game && typeof state.game.reset==='function') state.game.reset(); setScore(0); setTime(state.game?.timeLimit ?? null); }catch(e){ console.error(e); }
    });
    $('#btnNext')?.addEventListener('click', ()=>{ try{ state.game?.next && state.game.next(); }catch(e){ console.error(e); } });
  }
  document.addEventListener('DOMContentLoaded', wire);

  /* ===============================
     UTILITATS GEOMÈTRIQUES
     =============================== */
  const rnd = (min,max)=> Math.random()*(max-min)+min;
  const avg = arr => arr.reduce((a,b)=>a+b,0)/arr.length;
  function clone(poly){ return poly.map(([x,y])=>[x,y]); }
  function centroid(poly){ const cx=avg(poly.map(p=>p[0])), cy=avg(poly.map(p=>p[1])); return [cx,cy]; }
  function normalize(poly){ const [cx,cy]=centroid(poly); return poly.map(([x,y])=>[x-cx,y-cy]); }
  function rotate(poly,deg){ const a=deg*Math.PI/180, s=Math.sin(a), c=Math.cos(a); return poly.map(([x,y])=>[x*c-y*s, x*s+y*c]); }
  function translate(poly,dx,dy){ return poly.map(([x,y])=>[x+dx,y+dy]); }
  function scale(poly,sx,sy){ return poly.map(([x,y])=>[x*sx,y*sy]); }
  function shearX(poly,k){ return poly.map(([x,y])=>[x+k*y, y]); }
  function shearY(poly,k){ return poly.map(([x,y])=>[x, y+k*x]); }
  function nudgeVertex(poly,mag=6){
    const i=Math.floor(Math.random()*poly.length);
    return poly.map(([x,y],idx)=> idx===i? [x+rnd(-mag,mag), y+rnd(-mag,mag)] : [x,y]);
  }
  function drawPoly(ctx,poly,{x=0,y=0,stroke='#111827'}={}){
    ctx.save();
    ctx.translate(x,y);
    ctx.beginPath();
    ctx.moveTo(poly[0][0], poly[0][1]);
    for(let i=1;i<poly.length;i++) ctx.lineTo(poly[i][0], poly[i][1]);
    ctx.closePath();
    ctx.lineWidth=2; ctx.strokeStyle=stroke; ctx.stroke();
    ctx.restore();
  }

  /* ===============================
     JOC 1 — Rotation Rush (3 distractors amb canvis mínims)
     =============================== */
  const RotationRush = {
    name:'Rotation Rush', timeLimit:20,
    round:0, basePoly:null, choicesWrap:null, baseCtx:null, correctIndex:0, correctAngle:90,
    shapeset:[
      [[0,0],[62,6],[52,22],[90,34],[50,54],[74,70],[16,64],[10,42],[28,34],[6,18]],
      [[0,0],[70,0],[70,16],[36,16],[36,56],[14,56],[14,18],[2,18]],
      [[8,20],[58,0],[96,26],[68,36],[88,74],[44,56],[14,70],[30,40]],
      [[0,10],[48,10],[48,26],[34,26],[34,40],[76,40],[76,58],[12,58],[12,28],[0,28]],
      [[0,18],[54,18],[72,6],[88,20],[40,32],[82,44],[62,60],[0,60],[10,40]],
      [[0,8],[64,8],[50,22],[78,22],[28,58],[44,44],[0,44]]
    ],
    hint:'Toca l’opció que és exactament la rotació (sense cap deformació).',
    init(root,onScore){
      this.onScore=onScore; this.round=0;
      const wrap = document.createElement('div');
      wrap.className='grid'; wrap.style.gridTemplateColumns='1fr 1fr'; wrap.style.gap='10px';
      wrap.innerHTML = `
        <div>
          <canvas id="rr-base" width="260" height="260"></canvas>
          <div class="muted" style="margin-top:6px">Tria la rotació correcta (90°, 180° o 270°). Les altres 3 estan lleument alterades.</div>
        </div>
        <div><div id="rr-choices" class="grid" style="grid-template-columns:1fr 1fr; gap:8px"></div></div>`;
      root.appendChild(wrap);
      this.choicesWrap = $('#rr-choices', wrap);
      this.baseCtx = $('#rr-base', wrap).getContext('2d');
      this.next();
    },
    reset(){ this.round=0; this.next(); },
    next(){
      setTime(this.timeLimit); startTimer();
      this.round++; if(this.round>10){ endGame('win'); return; }

      // Base (no rotada)
      const raw = this.shapeset[Math.floor(Math.random()*this.shapeset.length)];
      const base = normalize(raw);
      this.basePoly = base;
      this.baseCtx.clearRect(0,0,260,260);
      drawPoly(this.baseCtx, translate(base,130,130), {stroke:'#111827'});

      // Rotació objectiu
      const angles=[90,180,270];
      this.correctAngle = angles[Math.floor(Math.random()*angles.length)];
      const rotated = rotate(base, this.correctAngle);

      // Genera 3 distractors amb canvis mínims (manté la mateixa rotació)
      const d1 = scale(rotated, rnd(0.9,0.95), rnd(1.03,1.07));          // lleu escala anisotròpica
      const d2 = shearX(rotated, rnd(0.08,0.14));                         // shear suau
      const d3 = nudgeVertex(rotated, 7);                                  // mou un vèrtex lleu

      const options = [
        {poly: rotated, exact:true},
        {poly: d1, exact:false},
        {poly: d2, exact:false},
        {poly: d3, exact:false}
      ];

      // barreja i pinta
      for (let i=options.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [options[i],options[j]]=[options[j],options[i]]; }
      this.choicesWrap.innerHTML='';
      options.forEach(opt=>{
        const cv=document.createElement('canvas'); cv.width=120; cv.height=120;
        const ctx=cv.getContext('2d');
        drawPoly(ctx, translate(opt.poly,60,60), {stroke:'#111827'});
        cv.addEventListener('click',()=> this.pick(opt.exact));
        this.choicesWrap.appendChild(cv);
      });
    },
    pick(ok){ if(ok){ this.onScore(10); this.next(); } else { this.onScore(-2); } }
  };

  /* ===============================
     JOC 2 — Symmetry Painter
     =============================== */
  const SymmetryPainter = {
    name:'Symmetry Painter', timeLimit:null,
    levelIndex:0, rows:0, cols:0, grid:[], target:[],
    levels:[
      {rows:12, cols:16, target:(r,c)=>(r>2&&r<9&&c<4&&(r+c)%2===0)},
      {rows:14, cols:20, target:(r,c)=>((r>3&&r<10&&c<6)&&(r%3===0||c%2===0))},
      {rows:16, cols:22, target:(r,c)=>((r>4&&r<12&&c<7)&&((r+c)%3===0))}
    ],
    hint:'Arrossega per pintar a la meitat dreta.',
    init(root,onScore){
      this.onScore=onScore; this.levelIndex=0;
      const wrap=document.createElement('div');
      wrap.innerHTML=`<div class="muted" style="margin-bottom:6px">Completa la simetria vertical</div>
        <div id="sym" class="gridcells"></div>`;
      root.appendChild(wrap);
      this.gridEl = $('#sym', wrap);
      this.load(0);
    },
    next(){ this.load((this.levelIndex+1)%this.levels.length); },
    load(i){
      this.levelIndex=i;
      const L=this.levels[i]; this.rows=L.rows; this.cols=L.cols;
      const half=Math.floor(this.cols/2);
      this.target=Array.from({length:this.rows},(_,r)=>Array.from({length:this.cols},(_,c)=> (c<half && L.target(r,c)?1:0)));
      this.grid=Array.from({length:this.rows},()=>Array(this.cols).fill(0));
      this.render();
    },
    render(){
      const g=this.gridEl;
      g.innerHTML=''; g.style.gridTemplateColumns=`repeat(${this.cols},22px)`;
      let painting=false;
      const toggle=(r,c)=>{ if(c<Math.floor(this.cols/2)) return; this.grid[r][c]=this.grid[r][c]?0:1; };
      for(let r=0;r<this.rows;r++) for(let c=0;c<this.cols;c++){
        const d=document.createElement('div'); d.className='cell';
        if(this.target[r][c]===1) d.classList.add('hint');
        if(this.grid[r][c]===1) d.classList.add('on');
        d.addEventListener('mousedown',(e)=>{ e.preventDefault(); painting=true; toggle(r,c); this.render(); });
        d.addEventListener('mouseover',()=>{ if(painting){ toggle(r,c); this.render(); }});
        d.addEventListener('touchstart',(e)=>{ e.preventDefault(); painting=true; toggle(r,c); this.render(); },{passive:false});
        d.addEventListener('touchmove',(e)=>{ e.preventDefault(); const t=e.changedTouches[0]; const el=document.elementFromPoint(t.clientX,t.clientY); if(el&&el.classList.contains('cell')) el.dispatchEvent(new Event('mouseover')); },{passive:false});
        g.appendChild(d);
      }
      const up=()=>painting=false;
      document.addEventListener('mouseup',up,{once:true});
      document.addEventListener('touchend',up,{once:true});
      this.check();
    },
    check(){
      const mid=Math.floor(this.cols/2);
      for(let r=0;r<this.rows;r++) for(let c=0;c<mid;c++)
        if(this.target[r][c]!==this.grid[r][this.cols-1-c]) return;
      this.onScore(20);
    }
  };

  /* ===============================
     JOC 3 — Map Hunt (arreglat)
     =============================== */
  const MapHunt = {
    name:'Map Hunt', timeLimit:null,
    idx:0, rows:0, cols:0, cell:34, player:{r:0,c:0}, targets:0,
    levels:[
      {rows:8,cols:8,start:[0,0],targets:3},
      {rows:10,cols:10,start:[2,2],targets:4},
      {rows:12,cols:12,start:[5,1],targets:5}
    ],
    hint:'Fes servir el D-pad o llisca sobre el mapa.',
    init(root,onScore){
      this.onScore=onScore; this.idx=0;
      const wrap=document.createElement('div');
      wrap.innerHTML=`<div style="display:grid;grid-template-columns:minmax(260px,1fr) 170px;gap:10px;align-items:start">
        <canvas id="mh" width="340" height="368" aria-label="Mapa"></canvas>
        <div>
          <div class="dpad">
            <div></div><button class="btn" data-dir="N" aria-label="Amunt">▲</button><div></div>
            <button class="btn" data-dir="W" aria-label="Esquerra">◀</button><div class="btn" disabled>·</div><button class="btn" data-dir="E" aria-label="Dreta">▶</button>
            <div></div><button class="btn" data-dir="S" aria-label="Avall">▼</button><div></div>
          </div>
          <p class="muted" style="margin-top:8px">Arriba a una vora per comptar una fita.</p>
        </div>
      </div>`;
      root.appendChild(wrap);
      this.cv = $('#mh', wrap); this.ctx=this.cv.getContext('2d');
      $$('[data-dir]', wrap).forEach(b=> b.addEventListener('click',()=> this.moveBy(b.dataset.dir)));

      // Gest de lliscament — compat ampliada
      let down=false, sx=0, sy=0;
      const onDown = (x,y)=>{ down=true; sx=x; sy=y; };
      const onUp = (x,y)=>{ if(!down) return; down=false;
        const dx=x-sx, dy=y-sy;
        if(Math.abs(dx)<20 && Math.abs(dy)<20) return;
        if(Math.abs(dx)>Math.abs(dy)) this.moveBy(dx>0?'E':'W'); else this.moveBy(dy>0?'S':'N');
      };
      // Pointer (si existeix)
      this.cv.addEventListener('pointerdown',e=>{ e.preventDefault(); onDown(e.clientX,e.clientY); this.cv.setPointerCapture(e.pointerId); },{passive:false});
      this.cv.addEventListener('pointerup',e=>{ e.preventDefault(); onUp(e.clientX,e.clientY); },{passive:false});
      // Touch fallback
      this.cv.addEventListener('touchstart',e=>{ e.preventDefault(); const t=e.changedTouches[0]; onDown(t.clientX,t.clientY); },{passive:false});
      this.cv.addEventListener('touchend',e=>{ e.preventDefault(); const t=e.changedTouches[0]; onUp(t.clientX,t.clientY); },{passive:false});
      // Mouse fallback
      this.cv.addEventListener('mousedown',e=>{ e.preventDefault(); onDown(e.clientX,e.clientY); });
      this.cv.addEventListener('mouseup',e=>{ e.preventDefault(); onUp(e.clientX,e.clientY); });

      this.load(0);
    },
    next(){ this.load((this.idx+1)%this.levels.length); },
    load(i){
      this.idx=i; const L=this.levels[i];
      this.rows=L.rows; this.cols=L.cols; this.player={r:L.start[0],c:L.start[1]}; this.targets=L.targets;
      this.cv.width=this.cols*this.cell; this.cv.height=this.rows*this.cell+28;
      this.draw();
    },
    moveBy(dir){ if(dir==='N') this.move(-1,0); if(dir==='S') this.move(1,0); if(dir==='W') this.move(0,-1); if(dir==='E') this.move(0,1); },
    move(dr,dc){
      this.player.r=clamp(this.player.r+dr,0,this.rows-1);
      this.player.c=clamp(this.player.c+dc,0,this.cols-1);
      this.draw();
      if(this.targets>0 && (this.player.r===0||this.player.c===0||this.player.r===this.rows-1||this.player.c===this.cols-1)){
        this.targets--; this.onScore(5); if(this.targets===0) alert('🎯 Nivell completat!');
      }
    },
    draw(){
      const g=this.ctx, cs=this.cell; g.clearRect(0,0,this.cv.width,this.cv.height);
      g.strokeStyle='#e5e7eb'; for(let r=0;r<this.rows;r++) for(let c=0;c<this.cols;c++) g.strokeRect(c*cs, r*cs, cs, cs);
      g.fillStyle='#2563eb'; g.fillRect(this.player.c*cs+4, this.player.r*cs+4, cs-8, cs-8);
      g.fillStyle='#1f2937'; g.fillRect(0, this.rows*cs, this.cv.width, 28);
      g.fillStyle='white'; g.font='12px system-ui'; g.fillText('🎯 pendents: '+this.targets, 8, this.rows*cs+18);
    }
  };

  /* ===============================
     JOC 4 — Pentomino Packing
     =============================== */
  const Pentomino = {
    name:'Pentomino Packing', timeLimit:null,
    level:0, rows:0, cols:0, cell:30, board:[], pieces:[], active:null, dragOff:[0,0], pendingDrop:false,
    hint:'Toca una peça → toca tauler → arrossega. Doble-tap: rotar · Mantén: reflectir.',
    baseShapes: {
      F:[[0,1],[1,0],[1,1],[1,2],[2,2]],
      L:[[0,0],[1,0],[2,0],[3,0],[3,1]],
      P:[[0,0],[0,1],[1,0],[1,1],[2,0]],
      T:[[0,0],[0,1],[0,2],[1,1],[2,1]],
      Z:[[0,0],[0,1],[1,1],[1,2],[1,3]],
      U:[[0,0],[0,2],[1,0],[1,1],[1,2]],
      V:[[0,0],[1,0],[2,0],[2,1],[2,2]]
    },
    levels:[
      {rows:5,cols:5,pieces:['F','L','P','T','Z']},
      {rows:6,cols:6,pieces:['F','L','P','T','Z','U','V']}
    ],
    init(root,onScore){
      this.onScore=onScore; this.level=0;
      const wrap=document.createElement('div');
      wrap.innerHTML=`
        <div style="display:grid;grid-template-columns:1fr 220px;gap:12px;align-items:start">
          <canvas id="pento"></canvas>
          <div>
            <div id="pList" style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:8px"></div>
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <button id="btnRot" class="btn">↻ Rotar</button>
              <button id="btnFlip" class="btn">⇋ Reflectir</button>
              <button id="btnResetP" class="btn">Reinicia</button>
            </div>
            <p class="muted" style="margin-top:6px">Doble-tap = rotar · mantenir = reflectir</p>
          </div>
        </div>`;
      root.appendChild(wrap);
      this.cv = $('#pento', wrap); this.ctx=this.cv.getContext('2d'); this.pList=$('#pList', wrap);
      $('#btnRot', wrap).addEventListener('click',()=>{ if(this.active!=null){ this.rotate(this.active); this.draw(); }});
      $('#btnFlip', wrap).addEventListener('click',()=>{ if(this.active!=null){ this.reflect(this.active); this.draw(); }});
      $('#btnResetP', wrap).addEventListener('click',()=> this.load(this.level));
      this.load(0);

      // Gestos
      let pressTimer=null, lastTap=0, dragging=false;
      this.cv.addEventListener('pointerdown',(e)=>{ e.preventDefault();
        const {x,y}=this.xy(e); const g=this.toGrid(x,y);
        if(this.pendingDrop && this.active!=null){ const p=this.pieces[this.active]; p.pos={x:g.c,y:g.r}; this.pendingDrop=false; }
        this.active=this.hitPiece(g.r,g.c);
        if(this.active!=null){ dragging=true; this.dragOff=[g.c-this.pieces[this.active].pos.x, g.r-this.pieces[this.active].pos.y]; }
        const t=Date.now(); if(t-lastTap<280 && this.active!=null){ this.rotate(this.active); this.draw(); lastTap=0; return; } lastTap=t;
        clearTimeout(pressTimer); pressTimer=setTimeout(()=>{ if(this.active!=null){ this.reflect(this.active); this.draw(); } },400);
        this.cv.setPointerCapture(e.pointerId);
      },{passive:false});
      this.cv.addEventListener('pointermove',(e)=>{ if(this.active==null || !dragging) return; clearTimeout(pressTimer);
        const {x,y}=this.xy(e); const g=this.toGrid(x,y); const p=this.pieces[this.active];
        p.pos={x:g.c - this.dragOff[0], y:g.r - this.dragOff[1]}; this.draw();
      });
      this.cv.addEventListener('pointerup',()=>{ clearTimeout(pressTimer);
        if(this.active==null) return; dragging=false;
        const p=this.pieces[this.active];
        if(this.canPlace(p)){ this.place(p,this.active); this.onScore(2); }
        this.draw(); if(this.isComplete()){ this.onScore(30); alert('🧩 Tauler completat!'); }
      });
    },
    next(){ this.load((this.level+1)%this.levels.length); },
    load(i){
      this.level=i; const L=this.levels[i];
      this.rows=L.rows; this.cols=L.cols; this.cv.width=this.cols*this.cell; this.cv.height=this.rows*this.cell;
      this.board=Array.from({length:this.rows},()=>Array(this.cols).fill(-1));
      this.pieces = L.pieces.map(k=>({id:k,cells:this.baseShapes[k].map(p=>[...p]),pos:{x:-99,y:-99},color:this.rand()}));
      this.renderPallet(); this.active=null; this.pendingDrop=false; this.draw();
    },
    renderPallet(){
      this.pList.innerHTML='';
      this.pieces.forEach((pc,idx)=>{
        const c=document.createElement('canvas'); c.width=100; c.height=70; c.style.background='#fff'; c.style.border='1px solid var(--line)'; c.style.borderRadius='8px';
        const g=c.getContext('2d'); const s=14; g.fillStyle=pc.color; pc.cells.forEach(([r,cx])=> g.fillRect(10+cx*s,10+r*s,s-2,s-2));
        c.addEventListener('click',()=>{ this.active=idx; this.pendingDrop=true; });
        this.pList.appendChild(c);
      });
    },
    xy(e){ const b=this.cv.getBoundingClientRect(); return {x:e.clientX-b.left, y:e.clientY-b.top}; },
    toGrid(x,y){ return { c:Math.floor(x/this.cell), r:Math.floor(y/this.cell) }; },
    hitPiece(r,c){ for(let i=this.pieces.length-1;i>=0;i--){ const p=this.pieces[i]; for(const [rr,cc] of p.cells){ if(p.pos.y+rr===r && p.pos.x+cc===c) return i; } } return null; },
    rotate(i){ const p=this.pieces[i]; p.cells=p.cells.map(([r,c])=>[c,-r]); const mr=Math.min(...p.cells.map(q=>q[0])), mc=Math.min(...p.cells.map(q=>q[1])); p.cells=p.cells.map(([r,c])=>[r-mr,c-mc]); },
    reflect(i){ const p=this.pieces[i]; const mc=Math.max(...p.cells.map(q=>q[1])); p.cells=p.cells.map(([r,c])=>[r,mc-c]); },
    rand(){ const cs=['#ef4444','#f59e0b','#10b981','#3b82f6','#a855f7','#ec4899','#14b8a6']; return cs[Math.floor(Math.random()*cs.length)]; },
    canPlace(p){ for(const [r,c] of p.cells){ const R=p.pos.y+r, C=p.pos.x+c; if(R<0||C<0||R>=this.rows||C>=this.cols) return false; if(this.board[R][C]!==-1) return false; } return true; },
    place(p,idx){ for(const [r,c] of p.cells){ this.board[p.pos.y+r][p.pos.x+c]=idx; } },
    isComplete(){ for(let r=0;r<this.rows;r++) for(let c=0;c<this.cols;c++) if(this.board[r][c]===-1) return false; return true; },
    draw(){
      const g=this.ctx, cs=this.cell; g.clearRect(0,0,this.cv.width,this.cv.height);
      g.strokeStyle='#e5e7eb'; for(let r=0;r<this.rows;r++) for(let c=0;c<this.cols;c++) g.strokeRect(c*cs,r*cs,cs,cs);
      for(let r=0;r<this.rows;r++) for(let c=0;c<this.cols;c++){ const idx=this.board[r][c]; if(idx>=0){ g.fillStyle=this.pieces[idx].color; g.fillRect(c*cs+1,r*cs+1,cs-2,cs-2); } }
      this.pieces.forEach((p)=>{ const anyInside = p.cells.some(([rr,cc])=>{ const R=p.pos.y+rr, C=p.pos.x+cc; return (R>=0&&C>=0&&R<this.rows&&C<this.cols); }); if(!anyInside) return;
        g.fillStyle=p.color; p.cells.forEach(([rr,cc])=>{ const R=p.pos.y+rr, C=p.pos.x+cc; if(R>=0&&C>=0&&R<this.rows&&C<this.cols) g.fillRect(C*cs+1,R*cs+1,cs-2,cs-2); });
      });
    }
  };

  /* ===============================
     JOC 5 — Paper Nets
     =============================== */
  const Nets = {
    name:'Paper Nets', timeLimit:null, idx:0, angle:25,
    levels:[
      {layout:[[0,1,0],[1,1,1],[0,1,0]],valid:true,label:'Creu (vàlid)'},
      {layout:[[1,1,1,1,1,1]],valid:false,label:'Tira de 6 (no vàlid)'},
      {layout:[[0,1,0],[1,1,1],[0,0,1]],valid:false,label:'T incomplet'}
    ],
    init(root,onScore){
      this.onScore=onScore; this.idx=0;
      const wrap=document.createElement('div');
      wrap.innerHTML=`<div style="display:grid;grid-template-columns:1fr 220px;gap:10px;align-items:start">
        <canvas id="netcv" width="520" height="340"></canvas>
        <div>
          <label class="muted">Angle: <span id="angv">25</span>°</label>
          <input id="angle" type="range" min="0" max="90" value="25" style="width:100%">
          <div style="display:flex;gap:6px;margin-top:8px">
            <button id="validate" class="btn">Valida</button>
            <button id="nextNet" class="btn">Següent</button>
          </div>
          <p id="netLabel" class="muted" style="margin-top:6px"></p>
        </div>
      </div>`;
      root.appendChild(wrap);
      this.cv=$('#netcv',wrap); this.ctx=this.cv.getContext('2d');
      $('#angle',wrap).addEventListener('input',(e)=>{ this.angle=+e.target.value; $('#angv',wrap).textContent=this.angle; this.draw(); });
      $('#validate',wrap).addEventListener('click',()=> this.validate());
      $('#nextNet',wrap).addEventListener('click',()=> this.next());
      this.load(0);
    },
    next(){ this.load((this.idx+1)%this.levels.length); },
    load(i){ this.idx=i; $('#netLabel').textContent=this.levels[i].label; this.draw(); },
    validate(){ const L=this.levels[this.idx]; if(L.valid){ this.onScore(10); alert('✅ És un desplegable vàlid.'); } else { this.onScore(-2); alert('❌ No plega a un cub.'); } },
    draw(){
      const ctx=this.ctx,W=this.cv.width,H=this.cv.height; ctx.clearRect(0,0,W,H);
      const m=this.levels[this.idx].layout; const nR=m.length, nC=Math.max(...m.map(r=>r.length));
      const s=Math.min((W-60)/nC,(H-60)/nR); const ox=(W-nC*s)/2, oy=(H-nR*s)/2;
      ctx.strokeStyle='#9ca3af'; ctx.lineWidth=1.5;
      for(let r=0;r<nR;r++) for(let c=0;c<m[r].length;c++) if(m[r][c]){ ctx.strokeRect(ox+c*s, oy+r*s, s, s); ctx.fillStyle='rgba(37,99,235,0.08)'; ctx.fillRect(ox+c*s, oy+r*s, s, s); }
      const lift=Math.sin(this.angle*Math.PI/180)*s;
      let cr=0,cc=0; outer: for(let r=0;r<nR;r++) for(let c=0;c<nC;c++) if(m[r][c]){ cr=r; cc=c; break outer; }
      ctx.fillStyle='rgba(16,185,129,0.15)'; ctx.fillRect(ox+cc*s, oy+cr*s-lift, s, s);
      ctx.strokeStyle='#10b981'; ctx.strokeRect(ox+cc*s, oy+cr*s-lift, s, s);
    }
  };

  /* ---------- Registre ---------- */
  const GAMES = {
    rotation_rush: RotationRush,
    symmetry_painter: SymmetryPainter,
    map_hunt: MapHunt,
    pentomino: Pentomino,
    nets: Nets
  };

  /* Exposa startGame per si cal des de consola */
  window.startGame = startGame;

})();
</script>
</body>
</html>
