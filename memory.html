<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Memory de Sumes</title>
  <link rel="icon" href="favicon.svg" type="image/svg+xml">

  <!-- Tailwind CDN amb darkMode per classe -->
  <script>
    window.tailwind = { config: { darkMode: 'class' } };
  </script>
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    *,*::before,*::after{ box-sizing:border-box; }
    html,body,#root{ height:100%; width:100%; margin:0; }
    body{ min-height:100vh; min-width:100vw; overflow-x:hidden; overflow-y:auto; }
    #root{ display:flex; min-height:100vh; min-width:100vw; }
    .app-container{ flex:1 0 auto; min-height:100vh; width:100%; }
    @supports (height: 100dvh){ body,#root,.app-container{ min-height:100dvh; } }

    /* ===== Tauler: orientaci√≥ horitzontal per defecte (poques files, moltes columnes) */
    .board{
      display:grid;
      gap:.75rem;
      margin-inline:auto;        /* centrat */
      align-content:start;
      width:min(95vw, 1400px);   /* espai respirable a banda i banda */
    }

    /* Les columnes les fixa el JS en desktop/tablet.
       En m√≤bil forcem auto-fit per evitar scroll horitzontal. */
    @media (max-width: 640px){
      .board{
        grid-template-columns: repeat(auto-fit, minmax(90px, 1fr)) !important;
        width: min(96vw, 600px);
      }
    }

    /* ===== Flip 3D i feedback */
    .card-3d{ perspective:1000px; }
    .card-inner{
      position:relative; width:100%; height:100%;
      transform-style:preserve-3d;
      transition: transform .45s ease;
    }
    .card-face{
      backface-visibility:hidden; -webkit-backface-visibility:hidden;
      position:absolute; inset:0;
    }
    .card-front{ transform: rotateY(180deg); } /* CONTINGUT OCULT a l'inici */
    .card-back{ transform: rotateY(0deg); }    /* "?" VISIBLE a l'inici */
    .revealed .card-inner{ transform: rotateY(180deg); } /* mostra contingut */

    .shake { animation: shake .28s ease; }
    @keyframes shake{
      0%{ transform:translateX(0) } 25%{ transform:translateX(-6px) }
      50%{ transform:translateX(6px) } 75%{ transform:translateX(-4px) }
      100%{ transform:translateX(0) }
    }

    /* Safe-area padding (iPhone) per evitar anar enganxat a la vora */
    .px-safe{
      padding-left: max(1rem, env(safe-area-inset-left));
      padding-right: max(1rem, env(safe-area-inset-right));
    }
  </style>
</head>
<body class="transition-colors duration-300 bg-gradient-to-br from-purple-100 via-pink-100 to-blue-100 text-slate-800 dark:from-slate-950 dark:via-slate-900 dark:to-slate-900 dark:text-slate-100">
  <div id="root" class="app-container flex flex-col">
    <!-- Header (sense bot√≥ de mode fosc) -->
    <header class="w-full sticky top-0 z-10 backdrop-blur supports-[backdrop-filter]:bg-white/50 dark:supports-[backdrop-filter]:bg-slate-900/40 bg-white/70 dark:bg-slate-900/60 border-b border-white/30 dark:border-slate-700/50">
      <div class="max-w-7xl mx-auto px-safe py-4 flex items-center justify-between">
        <h1 class="text-3xl md:text-4xl font-black bg-gradient-to-r from-purple-600 via-pink-600 to-blue-600 bg-clip-text text-transparent">
          üß†‚ûï Memory de Sumes
        </h1>
      </div>
    </header>

    <!-- Controls -->
    <div class="max-w-7xl mx-auto w-full px-safe py-6">
      <div class="grid gap-4 md:grid-cols-[1fr_auto_auto_auto] items-end">
        <div class="rounded-2xl p-4 bg-white/70 dark:bg-slate-800/60 border border-black/5 dark:border-white/10 shadow-sm">
          <label class="block text-xs uppercase tracking-wide opacity-70 mb-1">Descripci√≥</label>
          <p class="text-sm opacity-90">
            Troba parelles <strong>Operaci√≥ ‚Üî Resultat</strong>. Orientaci√≥ <strong>m√©s horitzontal</strong>.
            Barreja real: operacions i resultats es dispersen (no queden totes de costat).
          </p>
        </div>

        <div class="rounded-2xl p-4 bg-white/70 dark:bg-slate-800/60 border border-black/5 dark:border-white/10 shadow-sm">
          <label for="tiles" class="block text-xs uppercase tracking-wide opacity-70 mb-1">Caselles</label>
          <select id="tiles"
                  class="w-full rounded-xl px-3 py-2 bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-700">
            <option value="10" selected>10 (5 parelles)</option>
            <option value="12">12 (6 parelles)</option>
            <option value="16">16 (8 parelles)</option>
            <option value="18">18 (9 parelles)</option>
            <option value="20">20 (10 parelles)</option>
          </select>
        </div>

        <div class="rounded-2xl p-4 bg-white/70 dark:bg-slate-800/60 border border-black/5 dark:border-white/10 shadow-sm">
          <label for="maxRes" class="block text-xs uppercase tracking-wide opacity-70 mb-1">Resultat m√†xim</label>
          <input id="maxRes" type="number" min="4" value="20"
                 class="w-36 rounded-xl px-3 py-2 bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-700" />
          <p class="text-xs mt-1 opacity-70">Recomanat ‚â• nombre de parelles + 1 (per resultats √∫nics).</p>
        </div>

        <div class="flex gap-2">
          <button id="new"
                  class="rounded-xl px-4 py-3 text-sm font-semibold shadow-lg shadow-emerald-500/20
                         bg-gradient-to-r from-emerald-400 to-emerald-600 text-white hover:shadow-emerald-500/30 hover:scale-[1.02] transition">
            Nova partida
          </button>
          <button id="reset"
                  class="rounded-xl px-4 py-3 text-sm font-semibold shadow-lg shadow-slate-900/10
                         bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-700 hover:scale-[1.02] transition">
            Reinicia
          </button>
        </div>
      </div>

      <!-- Stats -->
      <div class="mt-4 flex flex-wrap gap-3">
        <div class="rounded-xl px-4 py-2 bg-white/70 dark:bg-slate-800/60 border border-black/5 dark:border-white/10">
          ‚è±Ô∏è <span class="font-bold" id="time">00:00</span>
        </div>
        <div class="rounded-xl px-4 py-2 bg-white/70 dark:bg-slate-800/60 border border-black/5 dark:border-white/10">
          ‚úÖ Encerts: <span class="font-bold" id="hits">0</span>
        </div>
        <div class="rounded-xl px-4 py-2 bg-white/70 dark:bg-slate-800/60 border border-black/5 dark:border-white/10">
          ‚ùå Errors: <span class="font-bold" id="miss">0</span>
        </div>
      </div>

      <!-- Missatges -->
      <p id="message" class="mt-3 text-sm"></p>

      <!-- Board -->
      <main id="grid" class="board mt-6"></main>
    </div>

    <!-- Footer -->
    <footer class="mt-auto text-center p-4 text-xs text-slate-600 dark:text-slate-400 px-safe">
      <p>Joc creat per a GitHub Pages ¬∑ Sense depend√®ncies. Estil inspirat en ‚ÄúTutifruti‚Äù.</p>
      <p>Llic√®ncia: CC BY-NC-SA 4.0</p>
    </footer>
  </div>

  <script>
    // ===== Dark mode: mant√© funcionalitat sense bot√≥
    (function initTheme(){
      const rootEl = document.documentElement;
      const saved = localStorage.getItem('theme'); // 'dark' | 'light' (si ja existia de versions anteriors)
      const preferDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      if ((saved === 'dark') || (!saved && preferDark)) rootEl.classList.add('dark');
    })();

    // ===== Elements UI
    const els = {
      grid: document.getElementById('grid'),
      tiles: document.getElementById('tiles'),
      maxRes: document.getElementById('maxRes'),
      time: document.getElementById('time'),
      hits: document.getElementById('hits'),
      miss: document.getElementById('miss'),
      newBtn: document.getElementById('new'),
      resetBtn: document.getElementById('reset'),
      msg: document.getElementById('message'),
    };

    // ===== Estat
    let state = {
      deck: [],
      revealed: [],
      matchedKeys: new Set(),
      hits: 0,
      miss: 0,
      timerId: null,
      startTs: null,
      playing: false,
      lock: false,
      pairsNeeded: 0,
      cols: 0, rows: 0
    };

    // ===== Utils
    function mmss(ms){
      const s = Math.floor(ms/1000);
      const m = Math.floor(s/60);
      const r = s % 60;
      return String(m).padStart(2,'0')+':'+String(r).padStart(2,'0');
    }
    function startTimer(){
      if (state.timerId) return;
      state.startTs = Date.now();
      els.time.textContent = '00:00';
      state.timerId = setInterval(()=>{ els.time.textContent = mmss(Date.now()-state.startTs); }, 200);
    }
    function stopTimer(){ if (state.timerId){ clearInterval(state.timerId); state.timerId = null; } }
    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
    const randInt = (min,max)=> Math.floor(Math.random()*(max-min+1))+min;

    function pickRows(total){
      if (total <= 12) return 2;  // 10,12 ‚Üí 2 files
      return 3;                   // 16,18,20 ‚Üí 3 files
    }

    function makePairs(pairCount, maxR){
      const possibleSums = [];
      for(let s=2; s<=maxR; s++) possibleSums.push(s);
      if (pairCount > possibleSums.length){
        throw new Error(`Resultat m√†xim massa baix. Necessites com a m√≠nim ${pairCount+1}.`);
      }
      shuffle(possibleSums);
      const chosen = possibleSums.slice(0, pairCount);

      let nextId = 0;
      const pairs = chosen.map(sum => {
        const a = randInt(1, sum-1);
        const b = sum - a;
        const cardSum = { id: nextId++, key: sum, type:'sum', label: `${a} + ${b}` };
        const cardRes = { id: nextId++, key: sum, type:'res', label: String(sum) };
        return [cardSum, cardRes];
      });
      return pairs;
    }

    function countAdjacentPairs(deck, cols){
      const pos = new Map();
      deck.forEach((c, idx) => pos.set(c.id, { r: Math.floor(idx/cols), c: idx % cols, key: c.key, type: c.type }));
      const seen = new Set();
      let adj = 0;
      for (const {key} of deck){
        if (seen.has(key)) continue;
        const p = [...pos.values()].filter(v => v.key === key);
        if (p.length === 2){
          const sameRow = p[0].r === p[1].r;
          const sideBySide = sameRow && Math.abs(p[0].c - p[1].c) === 1;
          if (sideBySide) adj++;
        }
        seen.add(key);
      }
      return adj;
    }

    function buildDeck(total, maxR){
      const pairs = Math.floor(total/2);
      const rows = pickRows(total);
      const cols = Math.ceil(total / rows);
      const pairList = makePairs(pairs, maxR);

      let deck;
      do {
        deck = shuffle(pairList.flat());
        if (deck.length !== total) deck = deck.slice(0, total);
        const adj = countAdjacentPairs(deck, cols);
        if (adj === pairs) continue; // evita que TOTES les parelles quedin juntes
        break;
      } while(true);

      return { deck, rows, cols };
    }

    function render(){
      const g = els.grid;
      g.innerHTML = '';

      // Desktop/Tablet: forcem columnes; en m√≤bil un @media ho ignora (auto-fit)
      if (window.innerWidth > 640){
        g.style.gridTemplateColumns = `repeat(${state.cols}, minmax(120px, 1fr))`;
      } else {
        g.style.gridTemplateColumns = ''; // deixa l'auto-fit del CSS
      }

      state.deck.forEach(card=>{
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.dataset.id = card.id;
        btn.className =
          'card-3d relative h-[110px] sm:h-[130px] rounded-2xl focus:outline-none focus:ring-2 ' +
          'focus:ring-emerald-400/70 transition-transform';

        const inner = document.createElement('div');
        inner.className = 'card-inner';

        const front = document.createElement('div'); // contingut (ocult al principi)
        front.className =
          'card-face card-front rounded-2xl grid place-items-center ' +
          'bg-gradient-to-br from-emerald-400 to-emerald-600 text-white ' +
          'text-xl sm:text-2xl font-black border border-emerald-500/40 shadow-lg';
        front.textContent = card.label;

        const back = document.createElement('div');  // "?" visible al principi
        back.className =
          'card-face card-back rounded-2xl grid place-items-center ' +
          'bg-white dark:bg-slate-800 border border-slate-300 dark:border-slate-700 ' +
          'text-slate-600 dark:text-slate-200 text-3xl sm:text-4xl select-none';
        back.textContent = '?';

        inner.appendChild(front);
        inner.appendChild(back);
        btn.appendChild(inner);

        btn.addEventListener('click', ()=> onFlip(card.id));
        g.appendChild(btn);
      });

      updateCardClasses();
    }

    function setMessage(text, isError=false){
      els.msg.textContent = text || '';
      els.msg.className = 'mt-3 text-sm ' + (isError ? 'text-rose-500' : 'text-slate-600 dark:text-slate-300');
    }
    function setStats(){ els.hits.textContent = state.hits; els.miss.textContent = state.miss; }

    function updateCardClasses(){
      const map = new Map(state.deck.map(c=>[c.id, c]));
      [...els.grid.children].forEach(btn=>{
        const id = Number(btn.dataset.id);
        const card = map.get(id);
        const revealed = state.revealed.includes(id);
        const matched = state.matchedKeys.has(card.key);
        btn.classList.toggle('revealed', revealed || matched);
        if (matched){
          btn.classList.add('ring-2','ring-emerald-400/60');
        } else {
          btn.classList.remove('ring-2','ring-emerald-400/60');
        }
      });
    }

    function finishIfDone(){
      if (state.matchedKeys.size === state.pairsNeeded){
        stopTimer();
        setMessage(`üéâ Partida acabada en ${els.time.textContent}. Encerts: ${state.hits}, Errors: ${state.miss}`);
        state.playing = false;
      }
    }

    function onFlip(id){
      if (!state.playing || state.lock) return;
      const card = state.deck.find(c=>c.id===id);
      if (!card) return;
      if (state.matchedKeys.has(card.key)) return;
      if (!state.startTs) startTimer();
      if (state.revealed.includes(id)) return;

      state.revealed.push(id);
      updateCardClasses();

      if (state.revealed.length === 2){
        state.lock = true;
        const [id1,id2] = state.revealed;
        const c1 = state.deck.find(c=>c.id===id1);
        const c2 = state.deck.find(c=>c.id===id2);

        if (c1.key === c2.key && c1.type !== c2.type){
          state.hits++; setStats();
          state.matchedKeys.add(c1.key);
          setTimeout(()=>{ state.revealed = []; state.lock = false; updateCardClasses(); finishIfDone(); }, 250);
        } else {
          state.miss++; setStats();
          const setIds = new Set([id1,id2]);
          [...els.grid.children].forEach(b=>{
            const bid = Number(b.dataset.id);
            if (setIds.has(bid)){ b.classList.add('shake'); setTimeout(()=> b.classList.remove('shake'), 260); }
          });
          setTimeout(()=>{ state.revealed = []; state.lock = false; updateCardClasses(); }, 420);
        }
      }
    }

    function newGame(){
      stopTimer();
      state = { ...state, deck:[], revealed:[], matchedKeys:new Set(), hits:0, miss:0, timerId:null, startTs:null, playing:true, lock:false, pairsNeeded:0 };

      setStats(); els.time.textContent='00:00'; setMessage('');
      const total = Number(els.tiles.value);
      const pairs = Math.floor(total/2);
      const maxR = Number(els.maxRes.value);

      try{
        const { deck, rows, cols } = buildDeck(total, maxR);
        state.deck = deck;
        state.pairsNeeded = pairs;
        state.rows = rows;
        state.cols = cols;
        render();
      }catch(e){
        setMessage('‚ö†Ô∏è ' + e.message, true);
        state.playing = false;
        els.grid.innerHTML = '';
      }
    }

    function resetBoard(){
      if (!state.deck.length){ newGame(); return; }
      stopTimer();
      state.revealed = [];
      state.matchedKeys = new Set();
      state.hits = 0; state.miss = 0; state.startTs = null; state.playing = true; state.lock=false;
      setStats(); els.time.textContent='00:00'; setMessage('');
      render();
    }

    els.newBtn.addEventListener('click', newGame);
    els.resetBtn.addEventListener('click', resetBoard);

    // partida inicial
    newGame();

    // Re-render en canvis d‚Äôorientaci√≥/dispositiu per assegurar el layout √≤ptim
    window.addEventListener('resize', () => {
      if (!state.deck.length) return;
      render();
    });
  </script>
</body>
</html>
